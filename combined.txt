===== conn.go =====
package wsrooms

import (
	"fmt"
	"log"
	"net/http"
	"sync"
	"time"

	"github.com/google/uuid"
	"github.com/gorilla/websocket"
)

type MessageHandler func(c *Conn, msg *Message) error
type Authorize func(*http.Request) (map[string]string, error)

type Conn struct {
	ID     string
	Claims map[string]string
	send   chan []byte
	socket *websocket.Conn
    cleanupOnce sync.Once
}

const (
	writeWait      = 10 * time.Second
	pongWait       = 60 * time.Second
	pingPeriod     = pongWait * 9 / 10
	maxMessageSize = 65536
)

var (
	messageHandlersMu sync.RWMutex
	messageHandlers   = make(map[string]MessageHandler)
    upgrader = websocket.Upgrader{
        ReadBufferSize:  4096,
        WriteBufferSize: 4096,
        CheckOrigin:     func(r *http.Request) bool { return true },
    }
)

// RegisterHandler registers a custom event handler
func RegisterHandler(event string, handler MessageHandler) error {
	if event == "" {
		return fmt.Errorf("event name cannot be empty")
	}
	if handler == nil {
		return fmt.Errorf("handler cannot be nil")
	}
	messageHandlersMu.Lock()
	defer messageHandlersMu.Unlock()
	if _, exists := messageHandlers[event]; exists {
		return fmt.Errorf("handler for event %q already registered", event)
	}
	messageHandlers[event] = handler
	return nil
}

func (c *Conn) SendToRoom(roomName, event string, payload []byte) {
	msg := NewMessage(roomName, event, "", c.ID, payload)
	if room, ok := hub.getRoom(roomName); ok {
		room.emit(c, msg)
	}
}

func (c *Conn) SendToClient(dstID, event string, payload []byte) {
	msg := NewMessage("", event, dstID, c.ID, payload)
	if dst, ok := hub.getConn(dstID); ok {
		dst.send <- msg.Bytes()
	}
}

func (c *Conn) handleData(msg *Message) {
	switch msg.Event {
	case "join":
		hub.joinRoom(msg.Room, c)
	case "leave":
		hub.leaveRoom(msg.Room, c)
	case "joined", "left":
		return
	default:
		if msg.Dst != "" {
			if dst, ok := hub.getConn(msg.Dst); ok {
				dst.send <- msg.Bytes()
			}
			return
		}
		var handler MessageHandler
		messageHandlersMu.RLock()
		if h, exists := messageHandlers[msg.Event]; exists {
			handler = h
		}
		messageHandlersMu.RUnlock()
		if handler != nil {
			if err := handler(c, msg); err != nil {
				log.Printf("Handler error for event %q from conn %s: %v", msg.Event, c.ID, err)
			}
			return
		}
		if room, ok := hub.getRoom(msg.Room); ok {
			room.emit(c, msg)
		}
	}
}

func (c *Conn) cleanup() {
    c.cleanupOnce.Do(func() {
        hub.leaveAllRooms(c)
        hub.removeConn(c.ID)
        c.socket.Close()
        close(c.send)
    })
}

func (c *Conn) readPump() {
	defer c.cleanup()
	c.socket.SetReadLimit(maxMessageSize)
	c.socket.SetReadDeadline(time.Now().Add(pongWait))
	c.socket.SetPongHandler(func(string) error {
		c.socket.SetReadDeadline(time.Now().Add(pongWait))
		return nil
	})
	for {
		_, data, err := c.socket.ReadMessage()
		if err != nil {
			break
		}
		msg := BytesToMessage(data)
		if msg == nil {
			log.Printf("Conn %s: malformed message", c.ID)
			break
		}
		c.handleData(msg)
	}
}

func (c *Conn) write(mt int, payload []byte) error {
	c.socket.SetWriteDeadline(time.Now().Add(writeWait))
	return c.socket.WriteMessage(mt, payload)
}

func (c *Conn) writePump() {
	ticker := time.NewTicker(pingPeriod)
	defer func() {
		ticker.Stop()
        c.cleanup()
	}()
	for {
		select {
		case msg, ok := <-c.send:
			if !ok {
				c.write(websocket.CloseMessage, []byte{})
				return
			}
			if err := c.write(websocket.BinaryMessage, msg); err != nil {
				return
			}
		case <-ticker.C:
			if err := c.write(websocket.PingMessage, []byte{}); err != nil {
				return
			}
		}
	}
}

func newConnection(w http.ResponseWriter, r *http.Request, claims map[string]string) *Conn {
	sock, err := upgrader.Upgrade(w, r, nil)
	if err != nil {
		return nil
	}
	id, err := uuid.NewRandom()
	if err != nil {
		sock.Close()
		return nil
	}
	return &Conn{
		ID:     id.String(),
		Claims: claims,
		socket: sock,
		send:   make(chan []byte, 256),
	}
}

func SocketHandler(authFn Authorize) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		if r.Method != "GET" {
			http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
			return
		}
		var claims map[string]string
		if authFn != nil {
			var err error
			claims, err = authFn(r)
			if err != nil {
				http.Error(w, "Unauthorized", http.StatusUnauthorized)
				return
			}
		}
		c := newConnection(w, r, claims)
		if c == nil {
			return
		}
		hub.addConn(c)
		go c.writePump()
		go c.readPump()
		hub.joinRoom("root", c)
	}
}

===== hub.go =====
package wsrooms

import "sync"

// manager manages all rooms and connections
type manager struct {
	mu    sync.RWMutex
	rooms map[string]*room
	conns map[string]*Conn
}

// Global hub instance
var hub = &manager{
	rooms: make(map[string]*room),
	conns: make(map[string]*Conn),
}

// getRoom returns a room by name
func (m *manager) getRoom(name string) (*room, bool) {
	m.mu.RLock()
	defer m.mu.RUnlock()
	r, ok := m.rooms[name]
	return r, ok
}

// getConn returns a connection by ID
func (m *manager) getConn(id string) (*Conn, bool) {
	m.mu.RLock()
	defer m.mu.RUnlock()
	c, ok := m.conns[id]
	return c, ok
}

// addConn adds a new connection
func (m *manager) addConn(c *Conn) {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.conns[c.ID] = c
}

// removeConn removes a connection
func (m *manager) removeConn(id string) {
	m.mu.Lock()
	defer m.mu.Unlock()
	delete(m.conns, id)
}

// joinRoom adds a connection to a room, creating the room if needed
func (m *manager) joinRoom(name string, c *Conn) {
	m.mu.Lock()
	defer m.mu.Unlock()
	room, ok := m.rooms[name]
	if !ok {
		room = newRoom(name)
		m.rooms[name] = room
	}
	room.join(c)
}

// leaveRoom removes a connection from a room
func (m *manager) leaveRoom(name string, c *Conn) {
	if room, ok := m.getRoom(name); ok {
		room.leave(c)
	}
}

// leaveAllRooms removes a connection from all rooms
func (m *manager) leaveAllRooms(c *Conn) {
	m.mu.RLock()
	rooms := make([]*room, 0, len(m.rooms))
	for _, r := range m.rooms {
		rooms = append(rooms, r)
	}
	m.mu.RUnlock()
	for _, r := range rooms {
		r.leave(c)
	}
}
// removeRoom deletes a room from the hub
func (m *manager) removeRoom(name string) {
	m.mu.Lock()
	defer m.mu.Unlock()
	delete(m.rooms, name)
}

===== msg.go =====
package wsrooms

import (
	"bytes"
	"encoding/binary"
)

// Message represents a length-prefixed message
type Message struct {
	RoomLength    int
	Room          string
	EventLength   int
	Event         string
	DstLength     int
	Dst           string
	SrcLength     int
	Src           string
	PayloadLength int
	Payload       []byte
}

// readString reads a length-prefixed string from a buffer
func readString(buf *bytes.Buffer) (string, int) {
	if buf.Len() < 4 {
		return "", 0
	}
	length := int(binary.BigEndian.Uint32(buf.Next(4)))
	if length < 0 || buf.Len() < length {
		return "", 0
	}
	return string(buf.Next(length)), length
}

// readPayload reads a length-prefixed byte slice from a buffer
func readPayload(buf *bytes.Buffer) ([]byte, int) {
	if buf.Len() < 4 {
		return nil, 0
	}
	length := int(binary.BigEndian.Uint32(buf.Next(4)))
	if length < 0 || buf.Len() < length {
		return nil, 0
	}
	return buf.Next(length), length
}

// BytesToMessage decodes bytes into a Message
func BytesToMessage(data []byte) *Message {
	if len(data) < 24 {
		return nil
	}
	buf := bytes.NewBuffer(data)
	msg := &Message{}
	msg.Room, msg.RoomLength = readString(buf)
	msg.Event, msg.EventLength = readString(buf)
	msg.Dst, msg.DstLength = readString(buf)
	msg.Src, msg.SrcLength = readString(buf)
	msg.Payload, msg.PayloadLength = readPayload(buf)
	return msg
}

// Bytes serializes a Message into bytes
func (msg *Message) Bytes() []byte {
	buf := bytes.NewBuffer([]byte{})
	binary.Write(buf, binary.BigEndian, uint32(msg.RoomLength))
	buf.Write([]byte(msg.Room))
	binary.Write(buf, binary.BigEndian, uint32(msg.EventLength))
	buf.Write([]byte(msg.Event))
	binary.Write(buf, binary.BigEndian, uint32(msg.DstLength))
	buf.Write([]byte(msg.Dst))
	binary.Write(buf, binary.BigEndian, uint32(msg.SrcLength))
	buf.Write([]byte(msg.Src))
	binary.Write(buf, binary.BigEndian, uint32(msg.PayloadLength))
	buf.Write(msg.Payload)
	return buf.Bytes()
}

// NewMessage builds a new Message
func NewMessage(room, event, dst, src string, payload []byte) *Message {
	return &Message{
		RoomLength:    len(room),
		Room:          room,
		EventLength:   len(event),
		Event:         event,
		DstLength:     len(dst),
		Dst:           dst,
		SrcLength:     len(src),
		Src:           src,
		PayloadLength: len(payload),
		Payload:       payload,
	}
}

===== room.go =====
package wsrooms

import (
	"encoding/json"
	"log"
	"sync"
)

type roomMessage struct {
	sender *Conn
	data   []byte
}

type room struct {
	Name       string
	members    map[string]*Conn
	register   chan *Conn
	unregister chan *Conn
	send       chan *roomMessage
	stop       chan struct{}
	stopOnce   sync.Once
	mu         sync.Mutex
}

// Join queues a connection to join
func (r *room) join(c *Conn) {
	r.register <- c
}

// Leave queues a connection to leave
func (r *room) leave(c *Conn) {
	r.unregister <- c
}

// Emit queues a message to all room members
func (r *room) emit(c *Conn, msg *Message) {
	r.send <- &roomMessage{c, msg.Bytes()}
}

func (r *room) snapshot() []string {
	r.mu.Lock()
	defer r.mu.Unlock()
	ids := make([]string, 0, len(r.members))
	for id := range r.members {
		ids = append(ids, id)
	}
	return ids
}

func (r *room) broadcast(msg *roomMessage) {
	r.mu.Lock()
	members := make([]*Conn, 0, len(r.members))
	for id, c := range r.members {
		if id != msg.sender.ID {
			members = append(members, c)
		}
	}
	r.mu.Unlock()
	for _, c := range members {
		select {
		case c.send <- msg.data:
		default:
			log.Printf("room %s: member %s is slow or disconnected, removing", r.Name, c.ID)
			r.leave(c)
			c.cleanup()
		}
	}
}

func (r *room) handleJoin(c *Conn) {
	r.mu.Lock()
	r.members[c.ID] = c
	r.mu.Unlock()
	members, err := json.Marshal(r.snapshot())
	if err != nil {
		log.Println("Error marshalling room members:", err)
		return
	}
	c.send <- NewMessage(r.Name, "join_ack", "", c.ID, members).Bytes()
	r.emit(c, NewMessage(r.Name, "new_member", "", "", []byte(c.ID)))
}

func (r *room) handleLeave(c *Conn) {
	r.mu.Lock()
	delete(r.members, c.ID)
	empty := len(r.members) == 0
	r.mu.Unlock()
	c.send <- NewMessage(r.Name, "leave_ack", "", c.ID, []byte(c.ID)).Bytes()
	r.emit(c, NewMessage(r.Name, "member_left", "", "", []byte(c.ID)))
	if empty {
		r.stopOnce.Do(func() {
			close(r.stop)
		})
	}
}

func (r *room) run() {
	for {
		select {
		case c := <-r.register:
			r.handleJoin(c)
		case c := <-r.unregister:
			r.handleLeave(c)
		case msg := <-r.send:
			r.broadcast(msg)
		case <-r.stop:
			hub.removeRoom(r.Name)
			return
		}
	}
}

// newRoom creates and runs a new room
func newRoom(name string) *room {
	r := &room{
		Name:       name,
		members:    make(map[string]*Conn),
		register:   make(chan *Conn, 16),
		unregister: make(chan *Conn, 16),
		send:       make(chan *roomMessage, 64),
		stop:       make(chan struct{}),
	}
	go r.run()
	return r
}
